'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var index = require('./index.js');
var path = require('path');
var path__default = _interopDefault(path);
var fs = require('fs');
var module$1 = _interopDefault(require('module'));
var codec = require('sourcemap-codec');
var index$1 = require('./index2.js');
var env = require('./env.js');

function create_app(_a) {
    var bundler = _a.bundler, manifest_data = _a.manifest_data, dev_port = _a.dev_port, dev = _a.dev, cwd = _a.cwd, src = _a.src, dest = _a.dest, routes = _a.routes, output = _a.output;
    if (!fs.existsSync(output))
        fs.mkdirSync(output);
    var path_to_routes = path.relative(output + "/internal", routes);
    var client_manifest = generate_client_manifest(manifest_data, path_to_routes, bundler, dev, dev_port);
    var server_manifest = generate_server_manifest(manifest_data, path_to_routes, cwd, src, dest, dev);
    var app = generate_app(manifest_data, path_to_routes);
    index.write_if_changed(output + "/internal/manifest-client.mjs", client_manifest);
    index.write_if_changed(output + "/internal/manifest-server.mjs", server_manifest);
    index.write_if_changed(output + "/internal/App.svelte", app);
}
function create_serviceworker_manifest(_a) {
    var manifest_data = _a.manifest_data, output = _a.output, client_files = _a.client_files, static_files = _a.static_files;
    var files = ['service-worker-index.html'];
    if (fs.existsSync(static_files)) {
        files = files.concat(index.walk(static_files));
    }
    else {
        // TODO remove in a future version
        if (fs.existsSync('assets')) {
            throw new Error("As of Sapper 0.21, the assets/ directory should become static/");
        }
    }
    var code = ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\texport const timestamp = " + Date.now() + ";\n\n\t\texport const files = [\n\t" + files.map(function (x) { return index.stringify('/' + x); }).join(',\n\t') + "\n];\n\t\texport { files as assets }; // legacy\n\n\t\texport const shell = [\n\t" + client_files.map(function (x) { return index.stringify('/' + x); }).join(',\n\t') + "\n];\n\n\t\texport const routes = [\n\t" + manifest_data.pages.map(function (r) { return "{ pattern: " + r.pattern + " }"; }).join(',\n\t') + "\n];\n\t").replace(/^\t\t/gm, '').trim();
    index.write_if_changed(output + "/service-worker.js", code);
}
function create_param_match(param, i) {
    return /^\.{3}.+$/.test(param)
        ? param.replace(/.{3}/, '') + ": d(match[" + (i + 1) + "]).split('/')"
        : param + ": d(match[" + (i + 1) + "])";
}
function generate_client_manifest(manifest_data, path_to_routes, bundler, dev, dev_port) {
    var page_ids = new Set(manifest_data.pages.map(function (page) {
        return page.pattern.toString();
    }));
    var server_routes_to_ignore = manifest_data.server_routes.filter(function (route) {
        return !page_ids.has(route.pattern.toString());
    });
    var component_indexes = {};
    var components = ("[\n\t\t" + manifest_data.components.map(function (component, i) {
        var annotation = bundler === 'webpack'
            ? "/* webpackChunkName: \"" + component.name + "\" */ "
            : '';
        var source = get_file(path_to_routes, component);
        component_indexes[component.name] = i;
        return "{\n\t\t\t\t\tjs: () => import(" + annotation + index.stringify(source) + "),\n\t\t\t\t\tcss: \"__SAPPER_CSS_PLACEHOLDER:" + index.stringify(component.file, false) + "__\"\n\t\t\t\t}";
    }).join(',\n\t\t\t\t') + "\n\t]").replace(/^\t/gm, '');
    var needs_decode = false;
    var routes = ("[\n\t\t\t\t" + manifest_data.pages.map(function (page) { return "{\n\t\t\t\t\t// " + page.parts[page.parts.length - 1].component.file + "\n\t\t\t\t\tpattern: " + page.pattern + ",\n\t\t\t\t\tparts: [\n\t\t\t\t\t\t" + page.parts.map(function (part) {
        var missing_layout = !part;
        if (missing_layout)
            return 'null';
        if (part.params.length > 0) {
            needs_decode = true;
            var props = part.params.map(create_param_match);
            return "{ i: " + component_indexes[part.component.name] + ", params: match => ({ " + props.join(', ') + " }) }";
        }
        return "{ i: " + component_indexes[part.component.name] + " }";
    }).join(',\n\t\t\t\t\t\t') + "\n\t\t\t\t\t]\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t]").replace(/^\t/gm, '');
    if (needs_decode) {
        routes = "(d => " + routes + ")(decodeURIComponent)";
    }
    return ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\t// webpack does not support export * as root_comp yet so do a two line import/export\n\t\timport * as root_comp from '" + index.stringify(get_file(path_to_routes, manifest_data.root), false) + "';\n\t\texport { root_comp };\n\t\texport { default as ErrorComponent } from '" + index.stringify(get_file(path_to_routes, manifest_data.error), false) + "';\n\n\t\texport const ignore = [" + server_routes_to_ignore.map(function (route) { return route.pattern; }).join(', ') + "];\n\n\t\texport const components = " + components + ";\n\n\t\texport const routes = " + routes + ";\n\n\t\t" + (dev ? "if (typeof window !== 'undefined') {\n\t\t\timport(" + index.stringify(index.posixify(path.resolve(__dirname, '../sapper-dev-client.js'))) + ").then(client => {\n\t\t\t\tclient.connect(" + dev_port + ");\n\t\t\t});\n\t\t}" : '') + "\n\t").replace(/^\t{2}/gm, '').trim();
}
function generate_server_manifest(manifest_data, path_to_routes, cwd, src, dest, dev) {
    var imports = [].concat(manifest_data.server_routes.map(function (route, i) {
        return "import * as route_" + i + " from " + index.stringify(index.posixify(path_to_routes + "/" + route.file)) + ";";
    }), manifest_data.components.map(function (component, i) {
        return "import * as component_" + i + " from " + index.stringify(get_file(path_to_routes, component)) + ";";
    }), "import * as root_comp from " + index.stringify(get_file(path_to_routes, manifest_data.root)) + ";", "import error from " + index.stringify(get_file(path_to_routes, manifest_data.error)) + ";");
    var component_lookup = {};
    manifest_data.components.forEach(function (component, i) {
        component_lookup[component.name] = i;
    });
    var code = "\n\t\t".replace(/^\t\t/gm, '').trim();
    var build_dir = index.posixify(path.normalize(path.relative(cwd, dest)));
    var src_dir = index.posixify(path.normalize(path.relative(cwd, src)));
    return ("\n\t\t// This file is generated by Sapper \u2014 do not edit it!\n\t\t" + imports.join('\n') + "\n\n\t\tconst d = decodeURIComponent;\n\n\t\texport const manifest = {\n\t\t\tserver_routes: [\n\t\t\t\t" + manifest_data.server_routes.map(function (route, i) { return "{\n\t\t\t\t\t// " + route.file + "\n\t\t\t\t\tpattern: " + route.pattern + ",\n\t\t\t\t\thandlers: route_" + i + ",\n\t\t\t\t\tparams: " + (route.params.length > 0
        ? "match => ({ " + route.params.map(create_param_match).join(', ') + " })"
        : "() => ({})") + "\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t\t\t],\n\n\t\t\tpages: [\n\t\t\t\t" + manifest_data.pages.map(function (page) { return "{\n\t\t\t\t\t// " + page.parts[page.parts.length - 1].component.file + "\n\t\t\t\t\tpattern: " + page.pattern + ",\n\t\t\t\t\tparts: [\n\t\t\t\t\t\t" + page.parts.map(function (part) {
        if (part === null)
            return 'null';
        var props = [
            "name: \"" + part.component.name + "\"",
            "file: " + index.stringify(part.component.file),
            "component: component_" + component_lookup[part.component.name]
        ].filter(Boolean);
        if (part.params.length > 0) {
            var params = part.params.map(create_param_match);
            props.push("params: match => ({ " + params.join(', ') + " })");
        }
        return "{ " + props.join(', ') + " }";
    }).join(',\n\t\t\t\t\t\t') + "\n\t\t\t\t\t]\n\t\t\t\t}"; }).join(',\n\n\t\t\t\t') + "\n\t\t\t],\n\n\t\t\troot_comp,\n\t\t\terror\n\t\t};\n\n\t\texport const build_dir = " + JSON.stringify(build_dir) + ";\n\n\t\texport const src_dir = " + JSON.stringify(src_dir) + ";\n\n\t\texport const dev = " + (dev ? 'true' : 'false') + ";\n\t").replace(/^\t{2}/gm, '').trim();
}
function generate_app(manifest_data, path_to_routes) {
    // TODO remove default layout altogether
    var max_depth = Math.max.apply(Math, index.__spread(manifest_data.pages.map(function (page) { return page.parts.filter(Boolean).length; })));
    var levels = [];
    for (var i = 0; i < max_depth; i += 1) {
        levels.push(i + 1);
    }
    var l = max_depth;
    var pyramid = "<svelte:component this=\"{level" + l + ".component}\" {...level" + l + ".props}/>";
    while (l-- > 1) {
        pyramid = ("\n\t\t\t<svelte:component this=\"{level" + l + ".component}\" segment=\"{segments[" + l + "]}\" {...level" + l + ".props}>\n\t\t\t\t{#if level" + (l + 1) + "}\n\t\t\t\t\t" + pyramid.replace(/\n/g, '\n\t\t\t\t\t') + "\n\t\t\t\t{/if}\n\t\t\t</svelte:component>\n\t\t").replace(/^\t\t\t/gm, '').trim();
    }
    return ("\n\t\t<!-- This file is generated by Sapper \u2014 do not edit it! -->\n\t\t<script>\n\t\t\timport { setContext, afterUpdate } from 'svelte';\n\t\t\timport { CONTEXT_KEY } from './shared';\n\t\t\timport Layout from '" + get_file(path_to_routes, manifest_data.root) + "';\n\t\t\timport Error from '" + get_file(path_to_routes, manifest_data.error) + "';\n\n\t\t\texport let stores;\n\t\t\texport let error;\n\t\t\texport let status;\n\t\t\texport let segments;\n\t\t\texport let level0;\n\t\t\t" + levels.map(function (l) { return "export let level" + l + " = null;"; }).join('\n\t\t\t') + "\n\t\t\texport let notify;\n\n\t\t\tafterUpdate(notify);\n\t\t\tsetContext(CONTEXT_KEY, stores);\n\t\t</script>\n\n\t\t<Layout segment=\"{segments[0]}\" {...level0.props}>\n\t\t\t{#if error}\n\t\t\t\t<Error {error} {status}/>\n\t\t\t{:else}\n\t\t\t\t" + pyramid.replace(/\n/g, '\n\t\t\t\t') + "\n\t\t\t{/if}\n\t\t</Layout>\n\t").replace(/^\t\t/gm, '').trim();
}
function get_file(path_to_routes, component) {
    if (component.default)
        return "./" + component.type + ".svelte";
    return index.posixify(path_to_routes + "/" + component.file);
}

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? path__default.resolve(dir) : process.cwd();
  var rootName = path__default.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var requireRelative_1 = requireRelative;

function find(ts, fn) {
    var e_1, _a;
    try {
        for (var ts_1 = index.__values(ts), ts_1_1 = ts_1.next(); !ts_1_1.done; ts_1_1 = ts_1.next()) {
            var t = ts_1_1.value;
            if (fn(t)) {
                return t;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ts_1_1 && !ts_1_1.done && (_a = ts_1.return)) _a.call(ts_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
}
var ChunkResolver = /** @class */ (function () {
    function ChunkResolver(opt) {
        this.resolve_id = opt.resolve_id;
        this.id = opt.id;
        this.internals = opt.internals;
        this.module_imports = opt.module_imports;
        this.chunks_from_modules = opt.chunks_from_modules;
        this.chunk_cache = new Map();
    }
    ChunkResolver.prototype.resolve_chunk_by_id = function (id) {
        return index.__awaiter(this, void 0, void 0, function () {
            return index.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resolve_chunk(this.resolve_id(id))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    ChunkResolver.prototype.resolve_chunk = function (s) {
        return index.__awaiter(this, void 0, void 0, function () {
            var id, chunk, internals, deps, transitive_deps, orphaned_module_ids, manifest, _a, _b, dep_name, dep_chunk, _c, _d, td, e_2_1, manifest_1, manifest_1_1, module_1, _loop_1, _e, _f, addl_module, _g, _h, proto_chunk, new_chunk, _j, _k, d;
            var e_2, _l, e_3, _m, e_4, _o, e_5, _p, e_6, _q, e_7, _r;
            return index.__generator(this, function (_s) {
                switch (_s.label) {
                    case 0:
                        if (!s) {
                            return [2 /*return*/, undefined];
                        }
                        id = this.id(s);
                        chunk = this.chunk_cache.get(id);
                        if (!!chunk) return [3 /*break*/, 9];
                        internals = this.internals(s);
                        deps = [];
                        transitive_deps = new Set();
                        orphaned_module_ids = new Set();
                        manifest = new Set(internals.manifest);
                        chunk = {
                            id: id,
                            facadeId: internals.facadeId,
                            name: internals.name,
                            file_name: internals.file_name,
                            manifest: manifest,
                            deps: deps,
                            transitive_deps: transitive_deps
                        };
                        this.chunk_cache.set(id, chunk);
                        _s.label = 1;
                    case 1:
                        _s.trys.push([1, 6, 7, 8]);
                        _a = index.__values(internals.dep_names), _b = _a.next();
                        _s.label = 2;
                    case 2:
                        if (!!_b.done) return [3 /*break*/, 5];
                        dep_name = _b.value;
                        return [4 /*yield*/, this.resolve_chunk_by_id(dep_name)];
                    case 3:
                        dep_chunk = _s.sent();
                        if (dep_chunk) {
                            deps.push(dep_chunk);
                            transitive_deps.add(dep_chunk);
                            try {
                                for (_c = (e_3 = void 0, index.__values(dep_chunk.transitive_deps)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    td = _d.value;
                                    transitive_deps.add(td);
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_m = _c.return)) _m.call(_c);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                        }
                        _s.label = 4;
                    case 4:
                        _b = _a.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_2_1 = _s.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_b && !_b.done && (_l = _a.return)) _l.call(_a);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        try {
                            // accumulate a set of orphaned_module_ids imported by this s but not any of imports.
                            for (manifest_1 = index.__values(manifest), manifest_1_1 = manifest_1.next(); !manifest_1_1.done; manifest_1_1 = manifest_1.next()) {
                                module_1 = manifest_1_1.value;
                                _loop_1 = function (addl_module) {
                                    var importer = find(transitive_deps, function (c) { return c.manifest.has(addl_module); });
                                    if (!importer) {
                                        orphaned_module_ids.add(addl_module);
                                    }
                                };
                                try {
                                    for (_e = (e_5 = void 0, index.__values(this.module_imports(module_1))), _f = _e.next(); !_f.done; _f = _e.next()) {
                                        addl_module = _f.value;
                                        _loop_1(addl_module);
                                    }
                                }
                                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                finally {
                                    try {
                                        if (_f && !_f.done && (_p = _e.return)) _p.call(_e);
                                    }
                                    finally { if (e_5) throw e_5.error; }
                                }
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (manifest_1_1 && !manifest_1_1.done && (_o = manifest_1.return)) _o.call(manifest_1);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        // if we have anything orphaned, then promote them to be a chunk of their own.
                        if (orphaned_module_ids.size) {
                            try {
                                for (_g = index.__values(this.chunks_from_modules(s, orphaned_module_ids)), _h = _g.next(); !_h.done; _h = _g.next()) {
                                    proto_chunk = _h.value;
                                    new_chunk = {
                                        id: proto_chunk.id,
                                        facadeId: proto_chunk.facadeId,
                                        file_name: proto_chunk.file_name,
                                        name: proto_chunk.name,
                                        manifest: new Set(proto_chunk.manifest),
                                        deps: [],
                                        transitive_deps: []
                                    };
                                    this.chunk_cache.set(proto_chunk.id, new_chunk);
                                    deps.push(new_chunk);
                                    transitive_deps.add(new_chunk);
                                    try {
                                        for (_j = (e_7 = void 0, index.__values(new_chunk.transitive_deps)), _k = _j.next(); !_k.done; _k = _j.next()) {
                                            d = _k.value;
                                            transitive_deps.add(d);
                                        }
                                    }
                                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                                    finally {
                                        try {
                                            if (_k && !_k.done && (_r = _j.return)) _r.call(_j);
                                        }
                                        finally { if (e_7) throw e_7.error; }
                                    }
                                }
                            }
                            catch (e_6_1) { e_6 = { error: e_6_1 }; }
                            finally {
                                try {
                                    if (_h && !_h.done && (_q = _g.return)) _q.call(_g);
                                }
                                finally { if (e_6) throw e_6.error; }
                            }
                        }
                        _s.label = 9;
                    case 9: return [2 /*return*/, chunk];
                }
            });
        });
    };
    ChunkResolver.prototype.chunks = function () {
        return this.chunk_cache.values();
    };
    return ChunkResolver;
}());

var inline_sourcemap_header = 'data:application/json;charset=utf-8;base64,';
function extract_sourcemap(raw, id) {
    var raw_map = undefined;
    var map = null;
    var code = raw.replace(/\/\*#\s+sourceMappingURL=(.+)\s+\*\//g, function (m, url) {
        if (raw_map) {
            // TODO should not happen!
            throw new Error("Found multiple sourcemaps in single file (" + id + ")");
        }
        raw_map = url;
        return '';
    }).trim();
    if (typeof raw_map === 'string') {
        if (raw_map.startsWith(inline_sourcemap_header)) {
            var json = Buffer.from(raw_map.slice(inline_sourcemap_header.length), 'base64').toString();
            map = JSON.parse(json);
        }
    }
    return {
        code: code,
        map: map
    };
}
function chunk_content_from_modules(modules, resolve) {
    var e_1, _a, e_2, _b, e_3, _c;
    var parts = [];
    var mappings = [];
    var sources = [];
    var sourcesContent = [];
    var names = [];
    try {
        for (var modules_1 = index.__values(modules), modules_1_1 = modules_1.next(); !modules_1_1.done; modules_1_1 = modules_1.next()) {
            var module_1 = modules_1_1.value;
            var _d = resolve(module_1), code = _d.code, map = _d.map;
            parts.push(code);
            if (map) {
                var lines = codec.decode(map.mappings);
                if (sources.length > 0 || names.length > 0) {
                    try {
                        for (var lines_1 = (e_2 = void 0, index.__values(lines)), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                            var line = lines_1_1.value;
                            try {
                                for (var line_1 = (e_3 = void 0, index.__values(line)), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
                                    var segment = line_1_1.value;
                                    // adjust source index
                                    if (segment[1] !== undefined)
                                        segment[1] += sources.length;
                                    // adjust name index
                                    if (segment[4])
                                        segment[4] += names.length;
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (line_1_1 && !line_1_1.done && (_c = line_1.return)) _c.call(line_1);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (lines_1_1 && !lines_1_1.done && (_b = lines_1.return)) _b.call(lines_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                sources.push.apply(sources, index.__spread(map.sources));
                sourcesContent.push.apply(sourcesContent, index.__spread(map.sourcesContent));
                names.push.apply(names, index.__spread(map.names));
                mappings.push.apply(mappings, index.__spread(lines));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (modules_1_1 && !modules_1_1.done && (_a = modules_1.return)) _a.call(modules_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (parts.length > 0) {
        return {
            code: parts.join('\n'),
            map: {
                version: 3,
                file: null,
                sources: sources,
                sourcesContent: sourcesContent,
                names: names,
                mappings: codec.encode(mappings)
            }
        };
    }
    throw new Error("Internal error: no content available for chunk");
}
function emit_code_and_sourcemap(_a) {
    var sourcemap = _a.sourcemap, sourcemap_url_prefix = _a.sourcemap_url_prefix, output_file_name = _a.output_file_name, _b = _a.output, map = _b.map, code = _b.code, emit = _a.emit;
    map = Object.assign({}, map, { file: output_file_name });
    if (sourcemap === true) {
        var sourcemap_path = emit(output_file_name + ".map", JSON.stringify(map, null, '	'));
        code += "\n/*# sourceMappingURL=" + sourcemap_url_prefix + sourcemap_path + " */";
    }
    if (sourcemap === 'inline') {
        var base64 = Buffer.from(JSON.stringify(map), 'utf8').toString('base64');
        code += "\n/*# sourceMappingURL=" + inline_sourcemap_header + base64 + " */";
    }
    return emit(output_file_name, code);
}

var version = "1.0.1";

var RollupResult = /** @class */ (function () {
    function RollupResult(duration, compiler, sourcemap) {
        var _this = this;
        this.duration = duration;
        this.sourcemap = sourcemap;
        this.errors = compiler.errors.map(munge_warning_or_error);
        this.warnings = compiler.warnings.map(munge_warning_or_error);
        this.chunks = compiler.chunks.map(function (chunk) { return ({
            file: chunk.fileName,
            imports: chunk.imports.filter(Boolean),
            modules: Object.keys(chunk.modules).map(function (m) { return index.normalize_path(m); })
        }); });
        this.dependencies = compiler.dependencies;
        this.assets = {};
        if (typeof compiler.input === 'string') {
            compiler.chunks.forEach(function (chunk) {
                if (compiler.input in chunk.modules) {
                    _this.assets.main = chunk.fileName;
                }
            });
        }
        else {
            var _loop_1 = function (name_1) {
                var file = compiler.input[name_1];
                var chunk = compiler.chunks.find(function (chnk) { return file in chnk.modules; });
                if (chunk)
                    this_1.assets[name_1] = chunk.fileName;
            };
            var this_1 = this;
            for (var name_1 in compiler.input) {
                _loop_1(name_1);
            }
        }
        this.summary = compiler.chunks.map(function (chunk) {
            var size_color = chunk.code.length > 150000 ? index.$.bold().red : chunk.code.length > 50000 ? index.$.bold().yellow : index.$.bold().white;
            var size_label = index.left_pad(index$1.prettyBytes(chunk.code.length), 10);
            var lines = [size_color(size_label + " " + chunk.fileName)];
            var deps = Object.keys(chunk.modules)
                .map(function (file) {
                return {
                    file: path.relative(process.cwd(), file),
                    size: chunk.modules[file].renderedLength
                };
            })
                .filter(function (dep) { return dep.size > 0; })
                .sort(function (a, b) { return b.size - a.size; });
            var total_unminified = deps.reduce(function (t, d) { return t + d.size; }, 0);
            deps.forEach(function (dep, i) {
                var c = i === deps.length - 1 ? '└' : '│';
                var line = "           " + c + " " + dep.file;
                if (deps.length > 1) {
                    var p = (100 * dep.size / total_unminified).toFixed(1);
                    line += " (" + p + "%)";
                }
                lines.push(index.$.gray(line));
            });
            return lines.join('\n');
        }).join('\n');
    }
    RollupResult.prototype.relative_dependencies = function (routes_dir) {
        var dependencies = {};
        Object.entries(this.dependencies).forEach(function (_a) {
            var _b = index.__read(_a, 2), key = _b[0], value = _b[1];
            dependencies[index.normalize_path(path.relative(routes_dir, key)).replace(/\\/g, '/')] = value;
        });
        return dependencies;
    };
    RollupResult.prototype.to_json = function (manifest_data, dirs) {
        var dependencies = (this.relative_dependencies(dirs.routes));
        return {
            bundler: 'rollup',
            shimport: version,
            assets: this.assets,
            dependencies: dependencies
        };
    };
    RollupResult.prototype.print = function () {
        var blocks = this.warnings.map(function (warning) {
            return warning.file
                ? "> " + index.$.bold(warning.file) + "\n" + warning.message
                : "> " + warning.message;
        });
        blocks.push(this.summary);
        return blocks.join('\n\n');
    };
    return RollupResult;
}());
function munge_warning_or_error(warning_or_error) {
    return {
        file: warning_or_error.filename,
        message: [warning_or_error.message, warning_or_error.frame].filter(Boolean).join('\n')
    };
}

var stderr = console.error.bind(console);
var rollup;
var get_entry_point_output_chunk = function (bundle, entry_point) {
    var e_1, _a;
    if (entry_point === undefined) {
        throw new Error("Internal error: entry_point cannot be undefined");
    }
    var entry_point_output_chunk;
    try {
        for (var _b = index.__values(Object.values(bundle)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var chunk = _c.value;
            if (chunk.facadeModuleId === entry_point) {
                entry_point_output_chunk = chunk;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!entry_point_output_chunk) {
        throw new Error("Internal error: No chunk for entry point: " + entry_point + " in: " + Object.keys(bundle));
    }
    if (entry_point_output_chunk.type !== 'chunk') {
        throw new Error("Internal error: Wrong type for entry point chunk: " + entry_point + " in: " + Object.keys(bundle));
    }
    return entry_point_output_chunk;
};
var RollupCompiler = /** @class */ (function () {
    function RollupCompiler(config) {
        this._ = this.get_config(config);
        this.input = null;
        this.warnings = [];
        this.errors = [];
        this.chunks = [];
        this.css_files = {};
        this.dependencies = {};
    }
    RollupCompiler.prototype.get_config = function (mod) {
        return index.__awaiter(this, void 0, void 0, function () {
            var entry_point, that, sourcemap, onwarn;
            var _this = this;
            return index.__generator(this, function (_a) {
                that = this;
                sourcemap = mod.output.sourcemap;
                // TODO this is hacky, and doesn't need to apply to all three compilers
                (mod.plugins || (mod.plugins = [])).push({
                    name: 'sapper-internal',
                    options: function (opts) {
                        that.input = opts.input;
                    },
                    buildStart: function (options) {
                        var input = options.input;
                        var inputs = [];
                        if (typeof input === 'string') {
                            inputs.push({ alias: 'main', file: input });
                        }
                        else if (Array.isArray(input)) {
                            inputs.push.apply(inputs, index.__spread(input.map(function (file) { return ({ file: file, alias: file }); })));
                        }
                        else {
                            for (var alias in input) {
                                inputs.push({ file: input[alias], alias: alias });
                            }
                        }
                        if (!entry_point) {
                            entry_point = inputs[0].file;
                        }
                    },
                    renderChunk: function (code, chunk) {
                        that.chunks.push(chunk);
                    },
                    transform: function (code, id) {
                        // rollup-plugin-svelte adds an import statement to the js file which references the css file
                        // that won't be able to be compiled as js, so we remove it here and store a copy to use later
                        if (/\.css$/.test(id)) {
                            that.css_files[id] = code;
                            return { code: '', moduleSideEffects: 'no-treeshake' };
                        }
                    },
                    generateBundle: function (options, bundle) {
                        return index.__awaiter(this, void 0, void 0, function () {
                            var entry_point_output_chunk, chunk_resolver, output_chunks, chunks, dependencies, chunks_1, chunks_1_1, chunk;
                            var e_2, _a;
                            var _this = this;
                            return index.__generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        entry_point_output_chunk = get_entry_point_output_chunk(bundle, entry_point);
                                        chunk_resolver = new ChunkResolver({
                                            id: function (chunk) { return chunk.fileName; },
                                            resolve_id: function (chunk_file) {
                                                var oc = bundle[chunk_file];
                                                return oc && oc.type === 'chunk' ? oc : undefined;
                                            },
                                            internals: function (chunk) { return ({
                                                id: chunk.fileName,
                                                facadeId: chunk.facadeModuleId,
                                                name: chunk.name,
                                                file_name: chunk.fileName,
                                                dep_names: chunk === entry_point_output_chunk ? index.__spread(chunk.imports) : index.__spread(chunk.imports, chunk.dynamicImports),
                                                manifest: Object.keys(chunk.modules),
                                                type: options.format === 'es' ? 'module' : 'script'
                                            }); },
                                            module_imports: function (js_module) {
                                                var module_info = _this.getModuleInfo(js_module);
                                                return index.__spread(module_info.importedIds, module_info.dynamicallyImportedIds).filter(function (id) { return /\.css$/.test(id); });
                                            },
                                            chunks_from_modules: function (chunk, css_modules) {
                                                var name = chunk.name + '.css';
                                                var file_name = emit_code_and_sourcemap({
                                                    sourcemap: sourcemap,
                                                    output: chunk_content_from_modules(css_modules, function (css_module) {
                                                        var code = that.css_files[css_module];
                                                        return code && extract_sourcemap(code, css_module);
                                                    }),
                                                    sourcemap_url_prefix: '',
                                                    output_file_name: name,
                                                    emit: function (filename, source) {
                                                        var moduleid = _this.emitFile({ name: filename, type: 'asset', source: source });
                                                        var file = _this.getFileName(moduleid);
                                                        return file;
                                                    }
                                                });
                                                return [{
                                                        id: file_name,
                                                        facadeId: chunk.facadeModuleId,
                                                        name: name,
                                                        file_name: file_name,
                                                        manifest: css_modules,
                                                        dep_names: []
                                                    }];
                                            }
                                        });
                                        output_chunks = Object.values(bundle).filter(function (output) { return output.type === 'chunk'; });
                                        return [4 /*yield*/, Promise.all(output_chunks.map(function (chunk) { return chunk_resolver.resolve_chunk(chunk); }))];
                                    case 1:
                                        chunks = _b.sent();
                                        dependencies = {};
                                        try {
                                            for (chunks_1 = index.__values(chunks), chunks_1_1 = chunks_1.next(); !chunks_1_1.done; chunks_1_1 = chunks_1.next()) {
                                                chunk = chunks_1_1.value;
                                                if (chunk.facadeId) {
                                                    dependencies[chunk.facadeId] = Array.from(chunk.transitive_deps).map(function (dep) { return dep.file_name; });
                                                }
                                            }
                                        }
                                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                        finally {
                                            try {
                                                if (chunks_1_1 && !chunks_1_1.done && (_a = chunks_1.return)) _a.call(chunks_1);
                                            }
                                            finally { if (e_2) throw e_2.error; }
                                        }
                                        that.dependencies = dependencies;
                                        return [2 /*return*/];
                                }
                            });
                        });
                    }
                });
                onwarn = mod.onwarn || (function (warning, handler) {
                    handler(warning);
                });
                mod.onwarn = function (warning) {
                    onwarn(warning, function (warn) {
                        _this.warnings.push(warn);
                    });
                };
                return [2 /*return*/, mod];
            });
        });
    };
    RollupCompiler.prototype.oninvalid = function (cb) {
        this._oninvalid = cb;
    };
    RollupCompiler.prototype.compile = function () {
        return index.__awaiter(this, void 0, void 0, function () {
            var config, sourcemap, start, bundle, err_1;
            return index.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._];
                    case 1:
                        config = _a.sent();
                        sourcemap = config.output.sourcemap;
                        start = Date.now();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 5, , 6]);
                        return [4 /*yield*/, rollup.rollup(config)];
                    case 3:
                        bundle = _a.sent();
                        return [4 /*yield*/, bundle.write(config.output)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, new RollupResult(Date.now() - start, this, sourcemap)];
                    case 5:
                        err_1 = _a.sent();
                        // flush warnings
                        stderr(new RollupResult(Date.now() - start, this, sourcemap).print());
                        handleError(err_1);
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    RollupCompiler.prototype.watch = function (cb) {
        return index.__awaiter(this, void 0, void 0, function () {
            var config, sourcemap, watcher;
            var _this = this;
            return index.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._];
                    case 1:
                        config = _a.sent();
                        sourcemap = config.output.sourcemap;
                        watcher = rollup.watch(config);
                        watcher.on('change', function (id) {
                            _this.chunks = [];
                            _this.warnings = [];
                            _this.errors = [];
                            _this._oninvalid(id);
                        });
                        watcher.on('event', function (event) {
                            switch (event.code) {
                                case 'FATAL':
                                    // TODO kill the process?
                                    if (event.error.filename) {
                                        // TODO this is a bit messy. Also, can
                                        // Rollup emit other kinds of error?
                                        event.error.message = [
                                            "Failed to build \u2014 error in " + event.error.filename + ": " + event.error.message,
                                            event.error.frame
                                        ].filter(Boolean).join('\n');
                                    }
                                    cb(event.error);
                                    break;
                                case 'ERROR':
                                    _this.errors.push(event.error);
                                    cb(null, new RollupResult(Date.now() - _this._start, _this, sourcemap));
                                    break;
                                case 'START':
                                case 'END':
                                    // TODO is there anything to do with this info?
                                    break;
                                case 'BUNDLE_START':
                                    _this._start = Date.now();
                                    break;
                                case 'BUNDLE_END':
                                    cb(null, new RollupResult(Date.now() - _this._start, _this, sourcemap));
                                    break;
                                default:
                                    console.log("Unexpected event " + event.code);
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    RollupCompiler.load_config = function (cwd) {
        return index.__awaiter(this, void 0, void 0, function () {
            var input, bundle, _a, code, defaultLoader, config;
            return index.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!rollup)
                            rollup = requireRelative_1('rollup', cwd);
                        input = path.resolve(cwd, 'rollup.config.js');
                        return [4 /*yield*/, rollup.rollup({
                                input: input,
                                inlineDynamicImports: true,
                                external: function (id) {
                                    return (id[0] !== '.' && !path.isAbsolute(id)) || id.slice(-5, id.length) === '.json';
                                }
                            })];
                    case 1:
                        bundle = _b.sent();
                        return [4 /*yield*/, bundle.generate({
                                exports: 'named',
                                format: 'cjs'
                            })];
                    case 2:
                        _a = index.__read.apply(void 0, [(_b.sent()).output, 1]), code = _a[0].code;
                        defaultLoader = require.extensions['.js'];
                        require.extensions['.js'] = function (module, filename) {
                            if (filename === input) {
                                module._compile(code, filename);
                            }
                            else {
                                defaultLoader(module, filename);
                            }
                        };
                        config = require(input).default;
                        delete require.cache[input];
                        return [2 /*return*/, config];
                }
            });
        });
    };
    return RollupCompiler;
}());
// copied from https://github.com/rollup/rollup/blob/master/cli/logging.ts
// and updated so that it will compile here
function handleError(err, recover) {
    if (recover === void 0) { recover = false; }
    var description = err.message || err;
    if (err.name)
        description = err.name + ": " + description;
    var message = (err.plugin
        ? "(plugin " + (err).plugin + ") " + description
        : description) || err;
    stderr(index.$.bold().red("[!] " + index.$.bold(message.toString())));
    if (err.url) {
        stderr(index.$.cyan(err.url));
    }
    if (err.loc) {
        stderr((err.loc.file || err.id) + " (" + err.loc.line + ":" + err.loc.column + ")");
    }
    else if (err.id) {
        stderr(err.id);
    }
    if (err.frame) {
        stderr(index.$.dim(err.frame));
    }
    if (err.stack) {
        stderr(index.$.dim(err.stack));
    }
    stderr('');
    if (!recover)
        process.exit(1);
}

const { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env;

const $ = {
	enabled: !NODE_DISABLE_COLORS && TERM !== 'dumb' && FORCE_COLOR !== '0',

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (str.includes(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			this.has.includes(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

var kleur = $;

/**
 * This has been adapted from `create-react-app`, authored by Facebook, Inc.
 * see: https://github.com/facebookincubator/create-react-app/tree/master/packages/react-dev-utils
 */



const errorLabel = 'Syntax error:';
const isLikelyASyntaxError = str => str.includes(errorLabel);

const exportRegex = /\s*(.+?)\s*(")?export '(.+?)' was not found in '(.+?)'/;
const stackRegex = /^\s*at\s((?!webpack:).)*:\d+:\d+[\s\)]*(\n|$)/gm;

function formatMessage(message, isError) {
	// Workaround to accommodate Webpack v5
	// It gives us an Object now, not a string...
	// Objects not identical; details > stack > message
	if (typeof message === 'object') {
		message = message.details || message.stack || message.message;
	}

	let lines = message.split('\n');

	if (lines.length > 2 && lines[1] === '') {
		lines.splice(1, 1); // Remove extra newline.
	}

	// Remove loader notation from filenames:
	//   `./~/css-loader!./src/App.css` ~~> `./src/App.css`
	if (lines[0].lastIndexOf('!') !== -1) {
		lines[0] = lines[0].substr(lines[0].lastIndexOf('!') + 1);
	}

	// Remove useless `entry` filename stack details
	lines = lines.filter(line => line.indexOf(' @ ') !== 0);

	// 0 ~> filename; 1 ~> main err msg
	if (!lines[0] || !lines[1]) {
		return lines.join('\n');
	}

	// Cleans up verbose "module not found" messages for files and packages.
	if (lines[1].startsWith('Module not found: ')) {
		lines = [
			lines[0],
			lines[1] // "Module not found: " is enough detail
				.replace("Cannot resolve 'file' or 'directory' ", '')
				.replace('Cannot resolve module ', '')
				.replace('Error: ', '')
				.replace('[CaseSensitivePathsPlugin] ', '')
		];
	}

	// Cleans up syntax error messages.
	if (lines[1].startsWith('Module build failed: ')) {
		lines[1] = lines[1].replace('Module build failed: SyntaxError:', errorLabel);
	}

	if (lines[1].match(exportRegex)) {
		lines[1] = lines[1].replace(exportRegex, "$1 '$4' does not contain an export named '$3'.");
	}

	lines[0] = kleur.inverse(lines[0]);

	// Reassemble & Strip internal tracing, except `webpack:` -- (create-react-app/pull/1050)
	return lines.join('\n').replace(stackRegex, '').trim();
}

var webpackFormatMessages = function (stats) {
	const json = stats.toJson({}, true);

	const result = {
		errors: json.errors.map(msg => formatMessage(msg)),
		warnings: json.warnings.map(msg => formatMessage(msg))
	};

	// Only show syntax errors if we have them
	if (result.errors.some(isLikelyASyntaxError)) {
		result.errors = result.errors.filter(isLikelyASyntaxError);
	}

	// First error is usually it; others usually the same
	if (result.errors.length > 1) {
		result.errors.length = 1;
	}

	return result;
};

var formatMessage_1 = formatMessage;
webpackFormatMessages.formatMessage = formatMessage_1;

var locPattern = /\((\d+):(\d+)\)$/;
function munge_warning_or_error$1(message) {
    // TODO this is all a bit rube goldberg...
    var lines = message.split('\n');
    var file = lines.shift()
        // eslint-disable-next-line
        .replace('[7m', '') // careful — there is a special character at the beginning of this string
        .replace('[27m', '')
        .replace('./', '');
    var line = null;
    var column = null;
    var match = locPattern.exec(lines[0]);
    if (match) {
        lines[0] = lines[0].replace(locPattern, '');
        line = +match[1];
        column = +match[2];
    }
    return {
        file: file,
        message: lines.join('\n')
    };
}
var WebpackResult = /** @class */ (function () {
    function WebpackResult(stats) {
        this.stats = stats;
        var info = stats.toJson();
        var messages = webpackFormatMessages(stats);
        this.errors = messages.errors.map(munge_warning_or_error$1);
        this.warnings = messages.warnings.map(munge_warning_or_error$1);
        this.duration = info.time;
        this.chunks = info.assets.map(function (chunk) { return ({ file: chunk.name }); });
        this.assets = info.assetsByChunkName;
    }
    WebpackResult.prototype.to_json = function (manifest_data, dirs) {
        return {
            bundler: 'webpack',
            shimport: null,
            assets: this.assets
        };
    };
    WebpackResult.prototype.print = function () {
        return this.stats.toString({ colors: true });
    };
    return WebpackResult;
}());

var webpack;
var WebpackCompiler = /** @class */ (function () {
    function WebpackCompiler(config) {
        if (!webpack)
            webpack = requireRelative_1('webpack', process.cwd());
        this._ = webpack(config);
    }
    WebpackCompiler.prototype.oninvalid = function (cb) {
        this._.hooks.invalid.tap('sapper', cb);
    };
    WebpackCompiler.prototype.compile = function () {
        var _this = this;
        return new Promise(function (fulfil, reject) {
            _this._.run(function (err, stats) {
                if (err) {
                    reject(err);
                    process.exit(1);
                }
                var result = new WebpackResult(stats);
                if (result.errors.length) {
                    console.error(stats.toString({ colors: true }));
                    reject(new Error("Encountered errors while building app"));
                }
                else {
                    fulfil(result);
                }
            });
        });
    };
    WebpackCompiler.prototype.watch = function (cb) {
        this._.watch({}, function (err, stats) {
            cb(err, stats && new WebpackResult(stats));
        });
    };
    return WebpackCompiler;
}());

function create_compilers(bundler, cwd, src, dest, dev) {
    return index.__awaiter(this, void 0, void 0, function () {
        var config, config;
        return index.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    env.set_dev(dev);
                    env.set_src(src);
                    env.set_dest(dest);
                    if (!(bundler === 'rollup')) return [3 /*break*/, 2];
                    return [4 /*yield*/, RollupCompiler.load_config(cwd)];
                case 1:
                    config = _a.sent();
                    validate_config(config, 'rollup');
                    normalize_rollup_config(config.client);
                    normalize_rollup_config(config.server);
                    if (config.serviceworker) {
                        normalize_rollup_config(config.serviceworker);
                    }
                    return [2 /*return*/, {
                            client: new RollupCompiler(config.client),
                            server: new RollupCompiler(config.server),
                            serviceworker: config.serviceworker && new RollupCompiler(config.serviceworker)
                        }];
                case 2:
                    if (bundler === 'webpack') {
                        config = require(path.resolve(cwd, 'webpack.config.js'));
                        validate_config(config, 'webpack');
                        return [2 /*return*/, {
                                client: new WebpackCompiler(config.client),
                                server: new WebpackCompiler(config.server),
                                serviceworker: config.serviceworker && new WebpackCompiler(config.serviceworker)
                            }];
                    }
                    // this shouldn't be possible...
                    throw new Error("Invalid bundler option '" + bundler + "'");
            }
        });
    });
}
function validate_config(config, bundler) {
    if (!config.client || !config.server) {
        throw new Error(bundler + ".config.js must export a { client, server, serviceworker? } object");
    }
}
function normalize_rollup_config(config) {
    if (typeof config.input === 'string') {
        config.input = path.normalize(config.input);
    }
    else {
        for (var name_1 in config.input) {
            config.input[name_1] = path.normalize(config.input[name_1]);
        }
    }
}

function create_manifest_data(cwd, extensions) {
    if (extensions === void 0) { extensions = '.svelte .html'; }
    var component_extensions = extensions.split(' ');
    // TODO remove in a future version
    if (!fs.existsSync(cwd)) {
        throw new Error("As of Sapper 0.21, the routes/ directory should become src/routes/");
    }
    function find_layout(file_name, component_name, dir) {
        if (dir === void 0) { dir = ''; }
        var ext = component_extensions.find(function (ext) { return fs.existsSync(path.join(cwd, dir, "" + file_name + ext)); });
        var file = index.posixify(path.join(dir, "" + file_name + ext));
        return ext
            ? {
                name: component_name,
                file: file
            }
            : null;
    }
    var components = [];
    var pages = [];
    var server_routes = [];
    var default_layout = {
        default: true,
        type: 'layout',
        name: '_default_layout',
        file: null
    };
    var default_error = {
        default: true,
        type: 'error',
        name: '_default_error',
        file: null
    };
    function walk(dir, parent_segments, parent_params, stack) {
        var items = fs.readdirSync(dir)
            .map(function (basename) {
            var resolved = path.join(dir, basename);
            var file = path.relative(cwd, resolved);
            var is_dir = fs.statSync(resolved).isDirectory();
            var ext = path.extname(basename);
            if (basename[0] === '_')
                return null;
            if (basename[0] === '.' && basename !== '.well-known')
                return null;
            if (!is_dir && !/^\.[a-z]+$/i.test(ext))
                return null; // filter out tmp files etc
            var segment = is_dir
                ? basename
                : basename.slice(0, -ext.length);
            if (/\]\[/.test(segment)) {
                throw new Error("Invalid route " + file + " \u2014 parameters must be separated");
            }
            var parts = get_parts(segment);
            var is_index = is_dir ? false : basename.startsWith('index.');
            var is_page = component_extensions.indexOf(ext) !== -1;
            var route_suffix = basename.slice(basename.indexOf('.'), -ext.length);
            parts.forEach(function (part) {
                if (part.qualifier && /[()?:]/.test(part.qualifier.slice(1, -1))) {
                    throw new Error("Invalid route " + file + " \u2014 cannot use (, ), ? or : in route qualifiers");
                }
            });
            return {
                basename: basename,
                ext: ext,
                parts: parts,
                file: index.posixify(file),
                is_dir: is_dir,
                is_index: is_index,
                is_page: is_page,
                route_suffix: route_suffix
            };
        })
            .filter(Boolean)
            .sort(comparator);
        items.forEach(function (item) {
            var segments = parent_segments.slice();
            if (item.is_index) {
                if (item.route_suffix) {
                    if (segments.length > 0) {
                        var last_segment = segments[segments.length - 1].slice();
                        var last_part = last_segment[last_segment.length - 1];
                        if (last_part.dynamic) {
                            last_segment.push({ dynamic: false, content: item.route_suffix });
                        }
                        else {
                            last_segment[last_segment.length - 1] = {
                                dynamic: false,
                                content: "" + last_part.content + item.route_suffix
                            };
                        }
                        segments[segments.length - 1] = last_segment;
                    }
                    else {
                        segments.push(item.parts);
                    }
                }
            }
            else {
                segments.push(item.parts);
            }
            var params = parent_params.slice();
            params.push.apply(params, index.__spread(item.parts.filter(function (p) { return p.dynamic; }).map(function (p) { return p.content; })));
            if (item.is_dir) {
                var component = find_layout('_layout', get_slug(item.file) + "__layout", item.file);
                if (component)
                    components.push(component);
                walk(path.join(dir, item.basename), segments, params, component
                    ? stack.concat({ component: component, params: params })
                    : stack.concat(null));
            }
            else if (item.is_page) {
                var component = {
                    name: get_slug(item.file),
                    file: item.file
                };
                components.push(component);
                var parts = (item.is_index && stack[stack.length - 1] === null)
                    ? stack.slice(0, -1).concat({ component: component, params: params })
                    : stack.concat({ component: component, params: params });
                pages.push({
                    pattern: get_pattern(segments, true),
                    parts: parts
                });
            }
            else {
                server_routes.push({
                    name: "route_" + get_slug(item.file),
                    pattern: get_pattern(segments, !item.route_suffix),
                    file: item.file,
                    params: params
                });
            }
        });
    }
    var root = find_layout('_layout', 'main') || default_layout;
    var error = find_layout('_error', 'error') || default_error;
    walk(cwd, [], [], []);
    // check for clashes
    var seen_pages = new Map();
    pages.forEach(function (page) {
        var pattern = page.pattern.toString();
        if (seen_pages.has(pattern)) {
            var file = page.parts.pop().component.file;
            var other_page = seen_pages.get(pattern);
            var other_file = other_page.parts.pop().component.file;
            throw new Error("The " + other_file + " and " + file + " pages clash");
        }
        seen_pages.set(pattern, page);
    });
    var seen_routes = new Map();
    server_routes.forEach(function (route) {
        var pattern = route.pattern.toString();
        if (seen_routes.has(pattern)) {
            var other_route = seen_routes.get(pattern);
            throw new Error("The " + other_route.file + " and " + route.file + " routes clash");
        }
        seen_routes.set(pattern, route);
    });
    return {
        root: root,
        error: error,
        components: components,
        pages: pages,
        server_routes: server_routes
    };
}
function is_spread(path) {
    var spread_pattern = /\[\.{3}/g;
    return spread_pattern.test(path);
}
function comparator(a, b) {
    if (a.is_index !== b.is_index) {
        if (a.is_index)
            return is_spread(a.file) ? 1 : -1;
        return is_spread(b.file) ? -1 : 1;
    }
    var max = Math.max(a.parts.length, b.parts.length);
    for (var i = 0; i < max; i += 1) {
        var a_sub_part = a.parts[i];
        var b_sub_part = b.parts[i];
        if (!a_sub_part)
            return 1; // b is more specific, so goes first
        if (!b_sub_part)
            return -1;
        // if spread && index, order later
        if (a_sub_part.spread && b_sub_part.spread) {
            return a.is_index ? 1 : -1;
        }
        // If one is ...spread order it later
        if (a_sub_part.spread !== b_sub_part.spread)
            return a_sub_part.spread ? 1 : -1;
        if (a_sub_part.dynamic !== b_sub_part.dynamic) {
            return a_sub_part.dynamic ? 1 : -1;
        }
        if (!a_sub_part.dynamic && a_sub_part.content !== b_sub_part.content) {
            return ((b_sub_part.content.length - a_sub_part.content.length) ||
                (a_sub_part.content < b_sub_part.content ? -1 : 1));
        }
        // If both parts dynamic, check for regexp patterns
        if (a_sub_part.dynamic && b_sub_part.dynamic) {
            var regexp_pattern = /\((.*?)\)/;
            var a_match = regexp_pattern.exec(a_sub_part.content);
            var b_match = regexp_pattern.exec(b_sub_part.content);
            if (!a_match && b_match) {
                return 1; // No regexp, so less specific than b
            }
            if (!b_match && a_match) {
                return -1;
            }
            if (a_match && b_match && a_match[1] !== b_match[1]) {
                return b_match[1].length - a_match[1].length;
            }
        }
    }
}
function get_parts(part) {
    return part.split(/\[(.+?\(.+?\)|.+?)\]/)
        .map(function (str, i) {
        if (!str)
            return null;
        var dynamic = i % 2 === 1;
        var _a = index.__read(dynamic
            ? /([^(]+)(\(.+\))?$/.exec(str)
            : [null, str, null], 3), content = _a[1], qualifier = _a[2];
        return {
            content: content,
            dynamic: dynamic,
            spread: /^\.{3}.+$/.test(content),
            qualifier: qualifier
        };
    })
        .filter(Boolean);
}
function get_slug(file) {
    var name = file
        .replace(/[\\/]index/, '')
        .replace(/[/\\]/g, '_')
        .replace(/\.\w+$/, '')
        .replace(/\[([^(]+)(?:\([^(]+\))?\]/, '$$$1')
        .replace(/[^a-zA-Z0-9_$]/g, function (c) {
        return c === '.' ? '_' : "$" + c.charCodeAt(0);
    });
    if (index.reserved_words.has(name))
        name += '_';
    return name;
}
function get_pattern(segments, add_trailing_slash) {
    var path = segments.map(function (segment) {
        return segment.map(function (part) {
            return part.dynamic
                ? part.qualifier || (part.spread ? '(.+)' : '([^/]+?)')
                : encodeURI(part.content.normalize())
                    .replace(/\?/g, '%3F')
                    .replace(/#/g, '%23')
                    .replace(/%5B/g, '[')
                    .replace(/%5D/g, ']')
                    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }).join('');
    }).join('\\/');
    var trailing = add_trailing_slash && segments.length ? '\\/?$' : '$';
    return new RegExp("^\\/" + path + trailing);
}

exports.create_app = create_app;
exports.create_compilers = create_compilers;
exports.create_manifest_data = create_manifest_data;
exports.create_serviceworker_manifest = create_serviceworker_manifest;
exports.version = version;
//# sourceMappingURL=create_manifest_data.js.map
